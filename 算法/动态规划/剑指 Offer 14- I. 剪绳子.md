# [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

## 方法一：动态规划

## 解题思路

![1.jpg](images/1619856597-QFTYyQ-1.jpg)

**当段长 m 满足 f(m) = max(f(i)×f(m-i)) < m 时，就说明此时不剪就是最优解，我们称之为“最优段”**。代码中给出了这个初始条件，就是 1，2，3。通过验证也确实说明了这点，1 就不用说了肯定不能剪了；2 的话如果剪得话只能是 1、1，由于 1×1<2 所以到 2 也不要再剪了；3 的话可以剪为 1、2，1×2<3, 所以到 3 的时候也不要再剪了；对于4，我们可以发现 2×2<=4， 这时候剪不剪都无所谓；对于5，2×3>5，这时候有必要剪一刀，而且**从4开始之后的都有必要剪**。

那么问题就来了，我们怎么确定**最优段**长是多少？不妨设初始条件对应的最优段为 m，剪完一刀后两段为 x、y (x+y=m)。如果这一刀存在那么下式肯定成立。**但是按照最优段的定义，这一刀是不存在的，那么我们需要求的最优段的解就是让下式不成立的 m 的取值范围**：

![image.png](images/1620191365-vOdPyG-image.png)

由于

![3.png](images/1619858248-CDjlha-3.png)

可以得到基本不等式

![4.png](images/1619858324-TlnIhu-4.png)

那么根据基本不等式可以得到不等式组为

![5.png](images/1619858446-xbrTzQ-5.png)

因为要求上式无解，即要求xy无解，那么必须满足

![6.png](images/1619858544-zgaSAm-6.png)

解得

![image.png](images/1619865475-Lnlmtm-image.png)

所以，在 m < 4 时，剪一刀后的结果 xy 是不会大于 x+y 的，那么剪到的**最优段长只能是 1、2、3**，也就是剪到这些段长的时候就不需要再去剪了！**当然如果 n < 4 时，因为题目要求必须剪一刀，所以这种情况作为特例判断并返回结果处理**。

## 复杂度分析

**时间复杂度：O(N^2)**

**空间复杂度：O(N)** 

## 代码实现

```golang
func cuttingRope(n int) int {
	if n < 2 { // 特判，n<4的几种情况
		return 0
	}
	if n == 2 { // 特判，n<4的几种情况
		return 1
	}
	if n == 3 { // 特判，n<4的几种情况
		return 2
	}
	// 动态规划思想
	// dp[i]表示把长度为i的绳子剪成若干段后各段长度乘积的最大值
	dp := make([]int, n+1)
	// 最优段初始化，无需剪断，自身为最优解（i<4）
	dp[1] = 1
	dp[2] = 2
	dp[3] = 3
	maxVal := 0
	for i := 4; i <= n; i++ {
		for j := 1; j <= i/2; j++ { // 只需遍历一半即可，另一半是对称的
			dp[i] = max(dp[i], dp[j]*dp[i-j])
		}
		maxVal = max(maxVal, dp[i])
	}
	return dp[n]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 方法二：贪心算法+数学

## 解题思路

**当 n>=5 时**， 可以证明 2(n-2)>n 并且 3(n-3)>n，进一步发现 3(n-3) >= 2(n-2)。**因此，当 n>=5 时应该尽可能地多剪长度为 3 的绳子段**。

**当 n=4 时**，绳子上剪一刀， 有两种可能的结果：剪成长度分别为 1 和 3 的两根绳子， 或者两根长度都为 2 的绳子。 注意到 2x2 > 1x3, 同时 2x2=4, 也就是说当 n=4 时其实没有必要剪， 只是题目的要求是至少要剪一刀。

## 复杂度分析

**时间复杂度：O(1)**

**空间复杂度：O(1)** 

## 代码实现

```golang
func cuttingRope(n int) int {
	if n < 2 { // 特判，n<4的几种情况
		return 0
	}
	if n == 2 { // 特判，n<4的几种情况
		return 1
	}
	if n == 3 { // 特判，n<4的几种情况
		return 2
	}
	// 尽可能多地剪去长度为 3 的绳子断
	timesOfThree := n / 3
	// 当绳子最后剩下的长度为 4 的时候，不能再剪去长度为 3 的绳子段
	// 此时更好的方法是把绳子剪成长度力 2 的两段， 因为 2x2>3x1
	if n-timesOfThree*3 == 1 {
		timesOfThree--
	}
	timesOfTwo := (n - timesOfThree*3) / 2 // 可能是 1 或 2
	return int(math.Pow(3, float64(timesOfThree)) * math.Pow(2, float64(timesOfTwo)))
}
```

